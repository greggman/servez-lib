<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="google" content="notranslate">
    <title>folder listing: {directory}</title>
    <style>
:root {
  color-scheme: dark light;
  --main-color: #000;
  --main-bg-color: #FFF;
  --odd-child: #EEE;
  --item-hover: #DDE;
  --item-hover-border: #AAA;
  --item-link: initial;
  --link-hover-bg: #DDE;
  --sort: seagreen;
  --search-bg: rgba(255, 255, 255, 0.9);
  --thumbnail-bg: var(--odd-child);
}
@media (prefers-color-scheme: dark) {
  :root {
    --main-color: #ccc;
    --main-bg-color: #333;
    --odd-child: #444;
    --item-hover: #556;
    --item-hover-border: #333;
    --item-link: #ACF;
    --link-hover-bg: #556;
    --sort: lightseagreen;
    --search-bg: rgba(0, 0, 0, 0.9);
  }
}
html {
  box-sizing: border-box;
}
*, *:before, *:after {
  box-sizing: inherit;
}
.icon-folder {
  background-image: url('data:image/svg+xml,<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M64,112L64,407.218C64,424.545 78.067,438.611 95.393,438.611L416.607,438.611C433.933,438.611 448,424.545 448,407.218L448,150.005C448,132.678 433.933,118.611 416.607,118.611L192,118.611L192,112C192,94.339 177.661,80 160,80L96,80C78.339,80 64,94.339 64,112Z" style="fill:rgb(127,127,127);fill-opacity:0.25;"/></svg>');
}
.icon-video {
  background-image: url('data:image/svg+xml,<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">    <g transform="matrix(7.34788e-17,1.2,-1.7103,1.04726e-16,765.778,-56.0063)">        <path d="M249.353,190.419C251.369,187.589 255.491,185.802 260,185.802C264.509,185.802 268.631,187.589 270.647,190.419C300.371,232.129 383.852,349.275 411.202,387.654C413.087,390.299 412.885,393.439 410.67,395.954C408.455,398.469 404.541,400 400.327,400L119.7,400C115.481,400 111.562,398.467 109.343,395.948C107.125,393.43 106.923,390.285 108.81,387.637C136.173,349.239 219.634,232.123 249.353,190.419Z" style="fill:rgb(128,128,128);fill-opacity:0.25;"/>    </g></svg>');
}
.icon-audio {
  background-image: url('data:image/svg+xml,<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:1.5;">    <path d="M177.369,192.601L256,136.922L256,375.078L177.369,319.399C175.831,319.791 174.219,320 172.557,320L83.443,320C72.712,320 64,311.288 64,300.557L64,211.443C64,200.712 72.712,192 83.443,192L172.557,192C174.219,192 175.831,192.209 177.369,192.601Z" style="fill:rgb(128,128,128);fill-opacity:0.25;stroke:rgb(128,128,128);stroke-opacity:0.25;stroke-width:33px;"/>    <g transform="matrix(1,0,0,0.875,26.4991,32)">        <path d="M282.253,192C311.244,234.667 311.787,277.333 282.253,320" style="fill:rgb(128,128,128);fill-opacity:0.25;stroke:rgb(128,128,128);stroke-opacity:0.25;stroke-width:30.86px;"/>    </g>    <g transform="matrix(1,0,0,0.875,38.0032,32)">        <path d="M320,160C360.808,222.975 362.32,286.937 320,352" style="fill:rgb(128,128,128);fill-opacity:0.25;stroke:rgb(128,128,128);stroke-opacity:0.25;stroke-width:30.86px;"/>    </g>    <g transform="matrix(1,0,0,0.875,47.2508,32)">        <path d="M357.727,128C414.666,210.167 415.513,295.453 357.727,384" style="fill:rgb(128,128,128);fill-opacity:0.25;stroke:rgb(128,128,128);stroke-opacity:0.25;stroke-width:30.86px;"/>    </g></svg>');
}

html, body {
  background-color: var(--main-bg-color);
  color: var(--main-color);
  font-family: monospace;
  font-size: large;
  height: 100%;
  overflow: none;
}
h1 {
    font-size: large;
}
:hover {
  cursor: pointer;
}
p {
  line-height: 1.5;
}
a {
  text-decoration: none;
}
#stacktrace {
  margin-top: 15px;
}
.directory h1 {
  margin-bottom: 15px;
}
.sort-up::after {
  content: "▲";
}
.sort-down::after {
  content: "▼";
}
.sort-down,
.sort-up {
  color: var(--sort);
}
table#files {
    padding: 0;
    width: 100%;
    table-layout: fixed;
}
table#files tr {
  
}
table#files tr:nth-child(odd) {
    background-color: var(--odd-child);
}
table#files tr {
  border: 1px solid transparent;
  border-radius: 5px;
  overflow: hidden;
}
table#files tr a {
  color: var(--item-link);
}
/* note: these are n, m, s because Kodi is hardcoded to look for these >:( */
/* name */
table#files td.i,
table#files th.i {
  font-size: medium;
  text-align: center;
  vertical-align: middle;  
  width: 1em;
}
table#files td.n {
}
table#files td.n a {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
}
/* date (modified) */
/* the align=right is required by kodi (T_T) */
table#files td.m,
table#files th.m,
table#files td[align=right] {
  text-align: center !important;
  white-space: nowrap;
  width: 11em;
}
/* size */
table#files td.s,
table#files th.s {
  text-align: right;
  width: 4em;
}

a:hover {
  background-color: var(--link-hover-bg);
}
table#files tr:focus,
table#files tr:hover {
  background-color: var(--item-hover);
  border: 1px solid var(--item-hover-border);
  cursor: pointer;
}
.hide,
.thumbnail.hide {
  display: none;
}
#header {
  display: flex;
  flex-direction: row-reverse;
  position: fixed;
  top: 0.5em;
  right: 0.5em;
  z-index: 1000;
}
#search {
  width: 15em;
  text-align: left;
  padding: .25em .5em;
  margin-bottom: 0;
  outline: none;
  background-color: var(--search-bg);
  border: 1px solid #ddd;
}

.image-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(256px, 1fr));
  gap: 1px;
}
.image-grid>* {
  overflow: hidden;
  word-break: break-all;
  word-wrap: break-word;
}
.image-grid video {
  object-fit: cover;
}
.thumbnail {
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  width: 100%;
  aspect-ratio: 1 / 1;
  text-align: center;
  background-size: cover;
  background-position: center center;
  background-color: var(--thumbnail-bg);
}
.thumbnail:hover {
  border: 1px solid white;
}
video {
  pointer-events: none;
}
.behind {
  position: absolute;
}
.thumbnail a {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  height: 100%;
}
.thumbnail .front {
  z-index: 1;
  position: absolute;
  width: 100%;
  height: 100%;
  background: none;
}

@media (max-width: 768px) {
  .image-grid {
    /* 119 makes 3 across on iPhone SE */
    grid-template-columns: repeat(auto-fit, minmax(119px, 2fr));
  }
}

@media (max-width: 600px) {
  #files td.s,
  #files th.s,
  #files th.m,
  table#files td[align=right] {
    display: none;
  }
}

@media (prefers-color-scheme: dark) {
  html {
    scrollbar-color: hsl(0, 0%, 35%) hsl(0, 0%, 13%);
  }
}
    </style>
  </head>
  <body class="directory">
    <div id="header"><input id="search" type="text" placeholder="Search" autocomplete="off" /></div>
    <div id="wrapper">
      <h1><a href="/">~</a>{linked-path}</h1>
      {files}
    </div>
    <script>
    "use strict";
    {
      function createElem(tag, attrs = {}, children = []) {
        if (Array.isArray(attrs)) {
          children = attrs;
          attrs = {};
        }
        const elem = document.createElement(tag);
        for (const [key, value] of Object.entries(attrs)) {
          if (typeof value === 'function' && key.startsWith('on')) {
            const eventName = key.substring(2).toLowerCase();
            elem.addEventListener(eventName, value, {passive: false});
          } else if (typeof value === 'object') {
            for (const [k, v] of Object.entries(value)) {
              elem[key][k] = v;
            }
          } else if (elem[key] === undefined) {
            elem.setAttribute(key, value);
          } else {
            elem[key] = value;
          }
        }
        for (const child of children) {
          elem.appendChild(child);
        }
        return elem;
      }

      function addElem(parent, tag, attrs = {}, children = []) {
        const elem = createElem(tag, attrs, children);
        parent.appendChild(elem);
        return elem;
      }

      function byTextContent(columnNdx) {
        return (a, b) => {
          const av = a.cells[columnNdx].textContent.toLowerCase();
          const bv = b.cells[columnNdx].textContent.toLowerCase();
          return av === bv ? 0 : av < bv ? -1 : 1;
        };
      }

      function unFormatBytes(str) {
        const suffixes = {
          'b': 0,
          'k': 2**10,
          'm': 2**20,
          'g': 2**30,
        };
        const mult = suffixes[str.slice(-1).toLowerCase()];
        if (mult === undefined) {
          return -1;
        }
        return parseFloat(str) * mult;
      };

      function bySizeAbbreviation(columnNdx) {
        return (a, b) => {
          const av = unFormatBytes(a.cells[columnNdx].textContent);
          const bv = unFormatBytes(b.cells[columnNdx].textContent);
          return av === bv ? 0 : av < bv ? -1 : 1;
        };
      }

      function reverseSort(sortFn) {
        return (a, b) => sortFn(b, a);
      }

      const searchElem = document.querySelector('#search');

      function search() {
        const str = searchElem.value.toLowerCase();
        const rows = document.querySelector('#files tbody').querySelectorAll('tr');

        const showHide = (text, elem) => {
          if ('..' == text) return;
          if (str.length && !~text.indexOf(str)) {
            elem.classList.add('hide');
          } else {
            elem.classList.remove('hide');
          }
        };

        rows.forEach(function(row){
          const link = row.querySelector('a');
          const text = row.textContent.toLowerCase();
          showHide(text, row);
        });

        [...imageGrid.children].forEach(elem => {
          const text = elem.textContent.toLowerCase();
          showHide(text, elem);
        });
      }

      searchElem.addEventListener('input', search);

      const table = document.querySelector('#files');

      const entries = [...table.rows].map(row => {
        const a = row.cells[1].querySelector('a');
        if (!a) {
          console.log(row);
        }
        return {
          name: a?.textContent,
          href: a?.href,
          date: row.cells[2].textContent,
          size: row.cells[3].textContent,
        };
      });

      const thead = addElem(table, 'thead');
      const tr = addElem(thead, 'tr');
      const headings = [
        { attribs: {textContent: '',     className: 'i'}, sortFn: byTextContent, },
        { attribs: {textContent: 'name', className: 'n'}, sortFn: byTextContent, },
        { attribs: {textContent: 'date', className: 'm'}, sortFn: byTextContent, },
        { attribs: {textContent: 'size', className: 's'}, sortFn: bySizeAbbreviation, },
      ];
      const headingElements = headings.map(heading => {
        const elem = addElem(tr, 'th', {
          ...heading.attribs,
          onClick: (e) => {
            const reverse = elem.classList.contains('sort-down');
            headingElements.forEach(elem => {
              elem.classList.remove('sort-up');
              elem.classList.remove('sort-down');
            });
            const sortBy = heading.attribs.className;
            sort(sortBy, reverse);
          },
        });
        return elem;
      });

      const kModeInfo = {
        listing: { text: '☰' },
        gallery: { text: '𝍖' },
      }
      const kModes = Object.keys(kModeInfo);
      const settings = {
        mode: kModes[0],
      };

      const updateHash = () => {
        const url = new URL(window.location.href);
        const params = new URLSearchParams(Object.entries(settings));
        url.hash = params.toString();
        history.replaceState(null, '', url.href);
      };

      const sort = (sortBy, reverse) => {
        settings.sortBy = sortBy;
        settings.reverse = reverse;
        const thead = document.querySelector('#files thead>tr');
        const th = thead.querySelector(`th.${sortBy}`);
        th.classList.add(reverse ? 'sort-up' : 'sort-down');

        const columnNdx = [...thead.cells].indexOf(th);
        const tbody = document.querySelector('#files tbody');
        const rows = [...tbody.rows];
        rows.forEach(row => row.remove());
        const sortFn = headings[columnNdx].sortFn(columnNdx);
        rows.sort(reverse ? reverseSort(sortFn) : sortFn);
        rows.forEach(row => tbody.appendChild(row));

        updateHash();
      };

      function makeClassName(...args) {
        return args.join(' ');
      }

      const imageGrid = addElem(document.querySelector('#wrapper'), 'div', {className: 'image-grid'});
      function createImageGrid() {
        if (imageGrid.children.length > 0) {
          return;
        }

        function makeLink({name, href, date, size}, {className} = {}) {
          return createElem('div', {
            className: makeClassName('thumbnail', className),
          }, [
            createElem('a', { href, textContent: name })
          ]);
        }

        function makeIcon(className) {
          return function(e) {
            return makeLink(e, {className});
          };
        }

        function makeImage({name, href, date, size}) {
          return createElem('a', {
            className: 'thumbnail',
            href,
            title: name,
            style: {
              backgroundImage: `url(${href})`,
            },
          }, [
            createElem('span', { style: { display: 'none', textContent: name }}),
          ]);
        }

        function makeVideo({name, href, date, size}) {
          return createElem('div', {
            className: 'thumbnail'
          }, [
            createElem('a', {
              className: 'behind thumbnail icon-video',
              textContent: name,
              href,
            }),
            createElem('video', {
              className: 'thumbnail',
              src: href,
              alt: name,
              loop: true,
              currentTime: 5,
            }),
            createElem('a', {
              className: 'front',
              href,
              title: name,
            }),
          ]);
        }

        function makeEmpty() {
          return createElem('div', {className: 'empty'});
        }

        const makeAudio = makeIcon('icon-audio');
        const makeVideoLink = makeIcon('icon-video');
        const makeAudioLink = makeIcon('icon-audio');
        const makeFolderLink = makeIcon('icon-folder');
        const makeExeLink = makeLink;

        const extFNs = {
          jpg: makeImage,
          jpeg: makeImage,
          png: makeImage,
          svg: makeImage,
          gif: makeImage,
          webp: makeImage,
          mp4: makeVideo,
          m4v: makeVideo,
          webm: makeVideo,
          mkv: makeVideo,
          mov: makeVideoLink,
          avi: makeVideoLink,
          wmv: makeVideoLink,
          mp3: makeAudio,
          m4a: makeAudio,
          ogg: makeAudioLink,
          wav: makeAudioLink,
          flac: makeAudioLink,
          acc: makeAudioLink,
          exe: makeExeLink,
        };

        entries.forEach(e => {
          const ext = e.name.substring(e.name.lastIndexOf('.') + 1);
          const fn = e.name.endsWith('/')
            ? makeFolderLink
            : extFNs[ext.toLowerCase()] || makeLink;
          imageGrid.appendChild(fn(e));
        });

        // these are needed to make the images not
        // spread when there are too few.
        for (let i = 0; i < 10; ++i) {
          imageGrid.appendChild(makeEmpty())
        }

        search();
      }

      function getNextMode() {
        return kModes[(kModes.indexOf(settings.mode) + 1) % kModes.length];
      }

      function updateMode(mode) {
        settings.mode = mode;
        const nextMode = getNextMode();
        modeButton.textContent = kModeInfo[nextMode].text;
        table.style.display = 'none';
        imageGrid.style.display = 'none';
        switch (mode) {
          case 'listing':
            table.style.display = '';
            break;
          case 'gallery':
            imageGrid.style.display = '';
            createImageGrid();
            break;
        }
        updateHash();
      }

      function cycleMode() {
        updateMode(getNextMode());
      }

      const heading = document.querySelector('#header');
      const modeButton = addElem(heading, 'button', {
        textContent: '𝍖',
        onClick: cycleMode,
      });

      {
        const {mode, sortBy, reverse} = Object.fromEntries(new URLSearchParams(window.location.hash.substring(1)).entries());
        if (mode) {
          updateMode(mode);
        }
        if (sortBy) {
          sort(sortBy, !!reverse);
        }
      }
    }

    {
      const icons = {
        jpg: '🏙',
        jpeg: '🏙',
        png: '🌄',
        gif: '🌠',
        mp4: '🎬',
        m4v: '🎬',
        mov: '🎬',
        avi: '🎬',
        mkv: '🎬',
        wmv: '🎬',
        mp3: '🔈',
        ogg: '🔈',
        wav: '🔈',
        flac: '🔈',
        acc: '🔈',
        exe: '☠️',
      };
      const extRE = /\.[^/.]*$/;
      document.querySelector('#files').querySelectorAll('tbody>tr').forEach(function(row) {
        const icon = row.querySelector('.i');
        const a = row.querySelector('a');
        const m = extRE.exec(a.href);
        const ext = m ? m[0].substr(1).toLowerCase() : '';
        icon.textContent = icons[ext] || (a.href.endsWith('/') ? '📁' : '📄');
      });
    }
    </script>
  </body>
</html>